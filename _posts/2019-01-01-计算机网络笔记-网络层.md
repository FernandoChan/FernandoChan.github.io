---
layout: post
title: "计算机网络之三--网络层"
author: "Fernando"
header-img: "img/post-bg-universe.jpg"
header-mask: 0.2
tags:
  - 计算机网络
  - IP协议
  - IPv4与IPv6地址
  - Routing Algorithm
  - RIP
  - OSPF
  - Routed Algorithm
  - 路由器工作原理
typora-copy-images-to: ..\img
---

网络层是处理端到端数据传输的最底层





# Routing Algorithm:

管理路由表并且就做出路由选择的算法

### 路由routing与转发forwarding的区别

routing包括两个进程, 一个是forwarding, 另一个是负责生成和更新路由表



虚电路: 只有当简历新的虚电路是, 才需要做路由决策

路由算法可以分成两大类: 

- non-adaptive (aka. static routing) : 不会根据目前乘凉或者估计的流量和拓扑结构来调整他们的路由决策, 相反, 所有的路由选择都是离线计算好的
  - Dijkstra 最短路径算法
  - Flooding
- adaptive (aka. Dynamic routing ) : 改变他们的路由决策一边反映出拓扑结构的变化, 通常也会反映出流量的变化情况 
  - DV
  - LS

# Distance-Vector Routing

最初用于1979年的Arpanet,后来被LS算法取代

# Link-State Routing

### 2设置链路成本

一种常用的选择是到邻居的成本与带宽成反比

1G bps 以太网的成本可能是1 , 那么100 Mbps的以太成本就是10

### 3构造Link state packet

![一个网络和LS包](H:\OneDrive\Project(sync with Github)\FernandoChan.github.io\img/1546758911804.png)

### 4 分发包Distributing LS packet

非常tricky的地方来了



对基础算法的改进: 

不是立即发包 , 而是放在保留区里面, 等待一段时间, 如果这个包在被forward之前,另一个来自包也来了, 那么就分别比较他们的**源路由器, 序列号和Age**

- if not 同一个源路由器, do nothing
- else if 来自同一个路由器, then 比较序列号, 
  - if 序列号相同, then **丢弃其中一个重复的包**, 并且**设置标志位**
  - else 比较Age, **丢弃老的数据包**

路由器B的保留区数据结构如下: ![路由器B的路由表](H:\OneDrive\Project(sync with Github)\FernandoChan.github.io\img/1546761284454.png)

**Send flags** 什么叫设置标志位呢? 上图红色区域的Send flags意思是从B的哪个邻居过来的, 看第三行, 从E发过来的包, 标志位里有两个0 , 说明到达了两次, 一次是经过A(路径是EAB), 一次是经过F(路径是EFB)

**ACK flags** 0位就是就是要通知的对象, 对Send flags 取反就行了



### LS算法的优势: 

- Consistency of each router is good
- Convergence is good 
- Fit for big network

为什么收敛性良好( 与DV作对比 ) 

### LS算法的缺点

- 每个

### 为什么叫Link State? 

## LS算法的实例----OSPF (open shortest path first)

1990年代替DV成为行业标准

## BGP(Border Gateway Protocol边界网关协议)

在一个AS内部, 推荐使用的路由协议是OSPF和IS-IS, 在`AS之间`, 则可以使用另一个协议BGP

- 是一个DV算法 , 但是与RIP不一样
- BGP路由器之间的通信是基于TCP的
- ​









# IP协议

路由器的主要工作过程

- De-encapsulation 解包
- Decide dest network 找到目的网络
- Lookup routing table 查找路由表
- Re-encapsulation and forward 重新封装并且转发

1. Routing
2. Forwarding
3. Other

## IP packet



## IP address

### IP 的分类



## Subnetting

对于一个borrow bit = 2 的一系列子网来说 , 真正有效的子网只有两个, 每个子网真正有效的只有`2^6 - 2= 62` 个

![img](https://raw.githubusercontent.com/FernandoChan/FernandoChan.github.io/8e41422e6cedd7247a89e6fc376db2c7a4121030/img/traditional_subnetting.png)

why some are invalid? 
这两个例题部分解释了为什么subnet划分子网的过程会导致浪费IP地址
传统的subnet方法中, 如果是2个borrowed bits 作为subnet, 有4个子网, 其中全0和全1 的无效,  剩下6位作为hosts, 那么只有62位是有效的
因此总的有效的数量是2*62 = 124. 对比原来的2^8-2 = 254, 少了接近一半

![书上的例子](https://raw.githubusercontent.com/FernandoChan/FernandoChan.github.io/8e41422e6cedd7247a89e6fc376db2c7a4121030/img/example_usingCIDR.jpg)

图中的电机工程系的子网为128.208.0.0/18

这是在CIDR的情况下，为了减少网络地址浪费，使用可变长子网掩码。

我们课程中，单纯说子网的划分，还是传统的subnetting, subnet部分不包含全0全1



例题2: 

Host IP部分也不能为全0 或全1 

![host](https://github.com/FernandoChan/FernandoChan.github.io/blob/8e41422e6cedd7247a89e6fc376db2c7a4121030/img/host%E4%B8%BB%E6%9C%BA%E6%AE%B5%E4%BE%8B%E9%A2%98.png?raw=true)

而192.168.10.14/28 最后一个字节   0000*1110* 不全为0



例题3: 

![img](https://raw.githubusercontent.com/FernandoChan/FernandoChan.github.io/8e41422e6cedd7247a89e6fc376db2c7a4121030/img/subnet%E6%AE%B5%E4%BE%8B%E9%A2%98%E7%AD%94%E6%A1%88.png)

答案是C

例题4: 

![img](https://raw.githubusercontent.com/FernandoChan/FernandoChan.github.io/8e41422e6cedd7247a89e6fc376db2c7a4121030/img/subnet%E6%AE%B5%E4%BE%8B%E9%A2%98%20.png)

202.38.197.32/27

202.38.197.64/27

202.38.197.96/27

202.38.197.128/27

为什么不用`202.38.197.0/27` ? 