---
layout: post
title: "面试算法之符号表到红黑树"
subtitle: ""
author: "Fernando"
header-img: "img/post-bg-universe.jpg"
header-mask: 0.2
tags:
  - 红黑树
  - ST符号表
  - BST二分查找树
typora-copy-images-to: ..\img
---



C++ 尤其是涉及到Socket编程层面的能力

- 使用C++ 实现这些功能
- 

数据库

redis 缓存技术

操作系统的内存对齐: 

内存的首部尾部包含其他信息

 





C++ 的虚函数表, 结合代码

`sizeof (type)`  等价于 `sizeof expression`

1. `sizeof(char)`, `sizeof(char8_t)`, `sizeof(signed char)`, and `sizeof(unsigned char)` always return 1.
2. sizeof cannot be used with function types, incomplete types, or bit-field glvalues.
3. When applied to a reference type, the result is the size of the referenced type.
4. When applied to a class type, the result is the size of an object of that class plus any additional padding required to place such object in an array.
5. When applied to an empty class type, always returns 1.
6. When applied to an expression, `sizeof` does [not evaluate the expression](https://en.cppreference.com/w/cpp/language/expressions#Unevaluated_expressions), and even if the expression designates a polymorphic object, the result is the size of the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed. [Temporary materialization](https://en.cppreference.com/w/cpp/language/implicit_cast#Temporary_materialization), however, is (formally) performed for prvalue arguments: sizeof determines the size of the result object. (since C++17)

```c
#include <iostream>
 
struct Empty {};
struct Base { int a; };
struct Derived : Base { int b; };
struct Bit { unsigned bit: 1; };
 
int main()
{
    Empty e;
    Derived d;
    Base& b = d;
    [[maybe_unused]] Bit bit;
    int a[10];
    std::cout << "size of empty class:              " << sizeof e        << "\n"
              << "size of pointer:                  " << sizeof &e       << "\n"
              << "size of pointer (2)               "  << sizeof &a        << "\n"
//            << "size of function:                "  << sizeof(void())  << "\n" // error
//            << "size of incomplete type:         "  << sizeof(int[])   << "\n" // error
//            << "size of bit field:               "  << sizeof bit.bit  << "\n" // error
              << "size of array of 10 int:         "  << sizeof(int[10]) << "\n"
              << "size of array of 10 int (2):     "  << sizeof a        << "\n"
              << "size of int                       "  << sizeof *a        << "\n"
              << "length of array of 10 int:       "  << ((sizeof a) / (sizeof *a)) << "\n"
              << "length of array of 10 int (2):   "  << ((sizeof a) / (sizeof a[0])) << "\n"
              << "size of the Derived:              " << sizeof d        << "\n"
              << "size of the Derived through Base: " << sizeof b        << "\n";
 
}
```

Possible output:

```
size of empty class:              1
size of pointer:                  8
size of pointer (2)               8
size of array of 10 int:         40
size of array of 10 int (2):     40
size of int                       4
length of array of 10 int:       10
length of array of 10 int (2):   10
size of the Derived:              8
size of the Derived through Base: 4
```

中间三行的报错信息: 

```sh
main.cpp: In function 'int main()':
main.cpp:17:69: error: invalid application of 'sizeof' to a function type [-Wpointer-arith]
             << "size of function:                "  << sizeof(void())  << "\n" // error
                                                                     ^
main.cpp:18:68: error: invalid application of 'sizeof' to incomplete type 'int []'
             << "size of incomplete type:         "  << sizeof(int[])   << "\n" // error
                                                                    ^
main.cpp:19:67: error: invalid application of 'sizeof' to a bit-field
             << "size of bit field:               "  << sizeof bit.bit  << "\n" // error
                                                                   ^~~
```



一个例子

```c
#include <stdio.h>
void test(int x[5]) {
        char a[5][6];
        printf("1.%ld", sizeof(x));
                    printf("2.%ld", sizeof(x[0]));
                        printf("3.%ld", sizeof(a));
                            printf("4.%ld", sizeof(a + 0));
                                printf("5.%ld", sizeof(&a));
}

int main(){
        int x[5] = {1,2,3,4,5};
        test(x);
}

//----output
1.8  x传入是作为数组之指针, 指针大小一直等于8
2.4  x[0] 是整数, 整数的大小为4
3.30 char数组为1*5*6 = 30 , 记得char的大小为1
4.8 a+0为当前指针
5.8  &a为当前指针
```



