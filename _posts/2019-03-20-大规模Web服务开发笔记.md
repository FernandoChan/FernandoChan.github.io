---
layout: post
title: "面试算法之符号表到红黑树"
subtitle: ""
author: "Fernando"
header-img: "img/post-bg-universe.jpg"
header-mask: 0.2
tags:
  - 红黑树
  - ST符号表
  - BST二分查找树
typora-copy-images-to: ..\img
---

这是一本比较旧(2010年出版

)的书, 里面涉及到的web服务端开发的基础知识比较多. 大规模指的是数据量超过了RDBMS处理能力的数据. 

先读并且记下来, 以后在真正的开发中可以复习.

---

1. 在大规模服务中要考虑什么问题?
   - 可扩展性和负载均衡(Scalability and Load Balance)
   - 冗余性Redundancy: 就算有一部分的服务器宕机也能避免雪崩
2. Scale up:  用更高速的硬件以提升单机性能 ; Scale Out : 增加廉价服务器的数量
3. 总线速度瓶颈 + 内存和磁盘$10^5 $~ $10^6$ 数量级的速度差异 是服务器性能瓶颈的主要的原因
4. 首先要确认**负载**有哪些, 通过以下方式看负载: 
	1. `top`和`uptime`查看平均负载
> 平均负载中的**负载**: 想要执行处理, 却无法执行而不得不等待的进程. 从操作系统的角度来理解的话, 就是等待获得CPU执行权限的进程 （ready state）+ 等待磁盘I/O完成的进程(block state)
>
> 2. 在**CPU**和**I/O**上找原因: 使用sar 查看服务器的I/O wait和CPU编号等.

5. Web程序的关键系统: Web应用服务器, 数据库服务器

Web应用服务器是**CPU密集型(CPU bound)**
数据库服务器是**I/O密集型(I/O bound)**

6. **CPU**负载的扩展十分简单, **I/O负载**的扩展却很难
> web application 在进行计算: 包括HTTP Request, 查询数据库, 返回查询结果并且生成HTML的过程中基本只消耗CPU. 从代理服务器到应用服务器不需要分散数据, 相同的主机做同样的工作就可以实现负载均衡了. 然而数据库服务器上的负载均衡就没那么容易了

7. 优化的方向有三个： 
	1. 了解操作系统的缓存原理, 使得尽可能在内存中完成. 缓存无法处理时, 进一步考虑分布式. 提高分布式中的Locality 
	2. 使用大规模环境下的算法和数据结构
	3. 数据压缩技术, 信息搜索技术

## 操作系统的缓存机制

**虚拟内存机制**:  操作系统吧文件进行了虚拟化,  所有的磁盘文件都不是每个字节每个字节地读取, 而是划分为一个个的**page**, page 也是虚拟化内存的最小单位. 

举个栗子:  假如你买了一个8GB内存处理器的电脑, 而你要打开40多G的DMC, 自然是远远超过了内存的容量, 所以操作系统就会用Paging技术, 在第一次读取一个文件的时候,  加载一部分本次需要用到的文件数据pages; 使用完关闭应用程序以后,  并不是直接清除这些页面, Linux执行的策略是: "只要有空闲内存, 就把页面留下来", 这样下次再次打开同一个程序的时候就可以直接**击中**, 提高加载速度. 这个过程就称作**缓存Caching**, 这样的话总是会越积越多, 所以操作系统上也会选择性地挑出一部分的页面置换出去, 使用的算法叫做**页面置换算法** , 其中最常用的一个就是**LRU(Least Recently Used)** 算法.



**Swapping** 交换文件: 使用了虚拟内存机制的一个功能, 当物理内存不足的时候, 将次级存储(主要是磁盘) 当成内存, 从表面上解决内存不足的问题



## 利用局部性的分布式

什么是局部性: 

单纯增加服务器的数量, 无法缓存的比例依然不变, 无法保证可扩展性